<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Library List</title>
    <style>
        body, table { font-family: Consolas, monospace; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { cursor: pointer; background-color: #f4f4f4; }
        .checked { text-decoration: line-through; color: gray !important; }
        .overdue-item { color: red; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Library List</h1>
    <table id="taskTable">
        <thead>
            <tr>
                <th>Found</th> <th onclick="sortTable(1)">Title</th> <th onclick="sortTable(2)">Due Date</th> </tr>
        </thead>
        <tbody>
            </tbody>
    </table>

    <script>
        let currentSortColumn = 2; // Default: Due Date
        let sortDirection = 1; // 1 = Ascending (Soonest first)

        document.addEventListener('DOMContentLoaded', () => {
            console.log("Initializing fetch...");
            fetch('output_html.txt')
                .then(response => {
                    if (!response.ok) throw new Error('Could not find output_html.txt');
                    return response.text();
                })
                .then(text => {
                    if (!text.trim()) throw new Error('File is empty');
                    loadCSV(text);
                })
                .catch(error => {
                    console.error('Error:', error);
                    const tbody = document.querySelector('#taskTable tbody');
                    tbody.innerHTML = `<tr><td colspan="3" style="color:red">Error: ${error.message}</td></tr>`;
                });
        });

        // Global variables for sorting state
        let currentSortColumn = 2; // Default to Due Date (index 2)
        let sortDirection = 1; // 1 for ascending, -1 for descending

        function loadCSV(text) {
            const tbody = document.querySelector('#taskTable tbody');
            const now = new Date();
            const uniqueTasks = new Map();

            // 1. Deduplicate: keep later due date for duplicate titles
            text.split('\n').forEach(line => {
                if (!line.includes('*^*')) return;
                const cols = line.split('*^*');
                const title = cols[0].trim();
                const dueDateStr = cols[1].trim();
                const dueDate = new Date(dueDateStr);

                if (!uniqueTasks.has(title) || dueDate > new Date(uniqueTasks.get(title))) {
                    uniqueTasks.set(title, dueDateStr);
                }
            });

            // 2. Generate Rows
            uniqueTasks.forEach((dueDateStr, title) => {
                const tr = document.createElement('tr');
                const taskId = `${title}|${dueDateStr}`;
                const isChecked = localStorage.getItem(taskId) === 'true';
                const dueDateObj = new Date(dueDateStr);
                
                if (isChecked) tr.classList.add('checked');
                // Only mark red if overdue AND not checked
                else if (dueDateObj < now) tr.classList.add('overdue-item');

                tr.innerHTML = `
                    <td><input type="checkbox" onchange="sortTasks(this)" ${isChecked ? 'checked' : ''}></td>
                    <td>${title}</td>
                    <td>${dueDateStr}</td>
                `;
                tbody.appendChild(tr);
            });

            // 3. Initial Sort: Soonest at top
            sortTable(2, true);
        }

        function sortTasks(checkbox) {
            const row = checkbox.parentElement.parentElement;
            const title = row.cells[1].innerText.trim();
            const dueDate = row.cells[2].innerText.trim();
            const taskId = `${title}|${dueDate}`;

            if (checkbox.checked) {
                localStorage.setItem(taskId, 'true');
                row.classList.add('checked');
                row.classList.remove('overdue-item');
            } else {
                localStorage.removeItem(taskId);
                row.classList.remove('checked');
                if (new Date(dueDate) < new Date()) row.classList.add('overdue-item');
            }
            sortTable(currentSortColumn, true);
        }

        function sortTable(columnIndex, maintainDirection = false) {
            const tbody = document.querySelector('#taskTable tbody');
            const rows = Array.from(tbody.rows);

            if (!maintainDirection && currentSortColumn === columnIndex) {
                sortDirection *= -1;
            } else {
                currentSortColumn = columnIndex;
                sortDirection = (columnIndex === 2) ? 1 : 1; // Default ascending
            }

            rows.sort((a, b) => {
                // Grouping: Unchecked always above Checked
                const aChecked = a.cells[0].querySelector('input').checked;
                const bChecked = b.cells[0].querySelector('input').checked;
                if (aChecked !== bChecked) return aChecked ? 1 : -1;

                // Sort logic
                let valA = a.cells[columnIndex].innerText.trim();
                let valB = b.cells[columnIndex].innerText.trim();

                if (columnIndex === 2) {
                    // Chronological Sort: (Date A - Date B) * 1 results in soonest first
                    return (new Date(valA) - new Date(valB)) * sortDirection;
                }
                return valA.localeCompare(valB) * sortDirection;
            });

            rows.forEach(row => tbody.appendChild(row));
        }
    </script>
</body>
</html>